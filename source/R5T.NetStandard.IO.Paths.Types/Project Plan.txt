R5T.NetStandard.IO.Paths.Types - A base types library for the R5T.NetStandard.IO.Paths library.

Goals

* Comment on System.IO.Path functionality.
* Combine path segments.
* Compute relative paths.
* Resolve paths. Resolving a path means transforming a path containing relative path segments (like "." and "..") to the corresponding absolute path.
* Normalize paths. Normalizing a path means taking a path that might have different directory separators, or other not yet encountered class of heterogeneity, and normalizing it to match the plain, simple, normal path, with only one directory separator or other single value from a heterogeneity class.
* Provide strongly-typed path parts that can be used as base-classes for other specific strongly-typed file and directory types.
* Provide utilities for manipulation paths at both the 1) string, and 2) strongly-typed levels of abstraction.
* Provide utilities that help ensure path correctness by performing various tests and manipulations on input values.
* Provide "Simple" utilities that perform NO tests or manipulations on input values to allow conceptual clarity. The default is to perform manipulations.
* Perform checks on stringly-typed input values to help ensure path correctness.
* Provide "Unchecked" utilities that skip performing checks for speed, simplicity, or non-standard uses. The default is to perform checks.


Summary

Paths are defined by how they start, and how they end. If a path starts with a root (directory-separator or volume and directory-separator) then the path is a rooted- (an absolute-) path. Else the path is a relative path that must be prefixed with a rooted path. If a path ends with a directory-separator, then it is a directory-path (although directory paths may not always end with a directory-separator, in which case at the string level of abstraction the directory-path is indistinguishable from a file-path, although a file-path is likely to end in a file-extension). Else the path could be assumed to be a file-path.

Thus there are four kinds of paths:

	* Absolute directory-path.
	* Relative directory-path.
	* Absolute file-path.
	* Relative file-path.

In the choice of absolute or relative, rooted is the default assumption for a path. Thus there are:

	* Paths.
	* Relative paths.

Regarding the middle of a path, a path be either resolved or unresolved. An unresolved path contains current-directory or parent-directory directory names ('.' or '..'). Path resolution is the process of following all current- or parent-directory name directions and getting the actual directory names corresponding to the destination. This results in a resolved path.

In the choice of resolved or unresolved, resolved is the default assumption for a path. Thus there are:

	* Paths.
	* Unresolved paths.

Finally, the directory-separator used in paths can be either the Windows or Non-Windows directory separator.

There is no default assumption on directory separator. This is done to allow the variety of cases where a non-Windows path would be used (remote file server, URI, etc.) to be treated as a first-class citizen and allow easy translation between the two environments.



Directory-Indicated and Root-Indicated

* A path is directory-indicated if it ends with a directory separator.
* A path is root-indicated if it begins with a directory separator (or a volume then a volume separator, then a directory separator).

The manipulation of paths as strings is built on two invariants of all paths:

* A directory path will always be directory-indicated (end with a directory separator).
* An absolute (or rooted) path will always be root-indicated (begin with a directory separator, or a volume, volume separator, then directory separator).


String Path Types

While there is no way to explicitly type a string (that is the reason for creating strongly-typed path types), string paths can be thought of as:

* Windows or Non-Windows.
* File or Directory.
* Absolute or Relative.


Windows or Non-Windows

Determining if a string path is a Windows or non-Windows path is a simple matter of determining if the path contains a Windows or non-Windows directory separator.

But what if a path is a "mixed" path (contains BOTH Windows and non-Windows directory separators)? This can result from combining a Windows absolute path and a non-Windows relative path, or vice-versa. In this case whichever directory separator comes first "dominates" the path (is closer to the root). Whichever directory separator dominates a mixed path determines with the path is a Windows or non-Windows path.

And what if a path has no directory separators? A real example is the relative paths of direct children, which is either just a file or directory name (if the directory name, as usual, is not directory-indicated). In this case "Default", "Strict", and base methods are provided. Default methods assume the directory separator being tested for in case none can be determined (e.g. IsWindowsPath() will assume that a path without any directory separators is a Windows path, and return true). Strict methods will not make any assumption if no directory separator can be determined (e.g. IsWindowsPathStrict() will return false since there is no directory separator available to strictly determine).


File or Directory

At the string-level of abstraction, directory paths can be indicated (end with a directory separator) or unindicated. The default is an indicated path, there there are directory paths and unindcated directory paths.


Relative Paths

What is a relative path? A relative path is a path that can be prefixed with a directory separator, then appended to a source absolute path, and when resolved, will yield a destination absolute path. More simply:

	absolution destination path = resolve(absolute source path + (directory separator + relative path))

At the string level of abstraction, there is no way to distinguish between a file path and an un-indicated directory path. Thus at the string level, five GetRelativePath() methods are provided:

	* GetRelativePath() - Assumes that input paths have been directory-indicated if they are directories, and are file paths otherwise.
	* GetRelativePathFileToFile() - Allows specifying that source and destination paths are file paths.
	* GetRelativePathFileToDirectory() - Allows specifying a source file path and destination directory path.
	* GetRelativePathDirectoryToFile() - Allows specifying a source directory path and destination file path.
	* GetRelativePathDirectoryToDirectory() - Allows specifying that source and destination paths are directory paths.


Relative Path Special Cases

What is the relative path from a path to the same path? This is just the empty string. Adding a directory separator and the empty string to a path resolves to the same path, for both files and directories.

It's very easy to determine the relative path to a file or directory in a directory, it's just the file or directory name.


Uri.MakeRelativeUri()

The Stack-Overflow suggested way to get a relative file path between two paths is to use the Uri class. This method generally works, but has some specific behaviors that differ from how file and directory paths are handled:

* Unless a directory path is directory-indicated, the Uri method assumes the directory path is a file path.
* The Uri method generates paths relative to the most-derived directory path in the source path. For a file path, this is the path of the directory containing the file.
* The Uri method, given a Windows path (using the the Windows directory separator), always returns a non-Windows path (using the non-Windows directory separator).
* The Uri method gives directory-indicated relative directory paths (which always end with the non-Windows directory separator).

These differences lead to failures on certain basic edge cases:

* Relative path from a file in a directory to another file in the same directory. Ex: "C:\Directory1\File1.txt -> C:\Directory1\File2.txt => "..\File2.txt". However, the Uri provides "File2.txt".
* Relative path from a directory to a file or directory within the directory. Ex: "C:\Directory1" -> "C:\Directory1\File1.txt" => "File1.txt". However, the Uri provides "Directory1\File1.txt". This is because the source directory path is not directory-indicated. If it is indicated, the correct answer results:  Ex: "C:\Directory1\" -> "C:\Directory1\File1.txt" => "File1.txt".




Note that a directory IS a file! However, note that directory paths can be indicated (i.e. end in a directory separator) or not. However, file paths never end in a directory separator.

Preserving the directory indicator is a necessity, as many libaries make assumptions about paths that require specific path values to end in a directory separator.

Thus, there is really only one path combination operation: joining a file path (no ending directory separator) to a non-rooted (no initial directory separator) path.

Directory path are (internally) always indicated.
Rooted paths are (internally) always indicated.

* A path is directory-indicated if it ends with a directory separator.
* A path is root-indicated if it begins with a directory separator (or a volume then a volume separator, then a directory separator).


Is() and Ensure()

A pair of Is() and Ensure() methods acts as a fundamental unit. The Is() method tests for some property, and Ensure() will, if needed, modify an input so that it's paired Is() method returns true.

Note that Ensure() methods cannot be created for operations that cannot be ensured! For example, ensuring that a path is strictly a Windows path cannot be done, since a relative file path that is just the file name cannot be ensured at the string level of abstraction.


Glossary

* Absolute.
* Assumed method.
* Directory-Indicated.
* Domination of path.
* Ensure.
* Is.
* Mixed.
* Relative.
* Root-Indicated.
* Rooted.
* Strict method.